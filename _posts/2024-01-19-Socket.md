---
layout: single
title:  "[Java] Socket"
typora-root-url: ../
---



간단한 소켓 통신을 통해 서버와 클라이언트 간의 채팅을 구현하는 예제를 통해 공부를 해보자.


```
package com.example.soketTest;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Iterator;
import java.util.Vector;

class Server extends Thread {

    Vector<ClientHandler> clientList = new Vector<>();

    ServerSocket ss;
    boolean running = true;

    public void run() {
        try {
            ss = new ServerSocket(8088); // ServerSocket 객체를 생성하여 클라이언트의 연결을 수락할 준비
            while (running && !Thread.currentThread().isInterrupted()) {
                System.out.println("Waiting client...");
                Socket s = ss.accept(); // accept()을 호출, 클라이언트가 연결 요청을 할 때까지 블록됨.
                // 클라이언트가 연결을 시도하면 `accept`는 해당 클라이언트와 통신할 수 있는 Socket객체를 반환한다. 
                System.out.println("Client connected.");
                ClientHandler client = new ClientHandler(this, s); 
                /*
                클라이언트와의 연결이 수락되면 `ClientHandler` 클래스의 인스턴스를 생성하고,
                해당 클라이언트와의 통신을 담당할 새로운 스레드로 시작함. 
                clientList에 이 클라이언트 핸들러를 추가하고, 스레드를 시작한다.
                */
                clientList.add(client);
                client.start();
            }
        } catch (Exception e) {
            System.out.println("error occurred. system will be down.");
            shutdown();
            /* 
            예외가 발생하면 해당 예외를 캐치하고 오류 메시지를 출력한다.
            그 후 shutdown 메서드를 호출하여 서버 및 클라이언트의 연결을 종료함.
            */
        }
    }

    void shutdown() {
        this.running = false;
        Iterator<ClientHandler> it = clientList.iterator();
        while (it.hasNext()) {
            ClientHandler client = it.next();
            client.disconnect();
            it.remove();
        }
        if (ss != null) try { ss.close(); } catch (Exception e) {}
    }

    void broadcast(String s) {
        for (ClientHandler client : clientList) {
            client.sendMessage(s);
        }
    }

}

class ClientHandler extends Thread {

    Server server;
    boolean running = true;
    Socket socket;
    BufferedReader in;
    PrintWriter out;

    public ClientHandler(Server server, Socket s) throws Exception {
        this.server = server;
        this.socket = s;
    }

    void disconnect() {
        System.out.println("ClientHandler.disconnect()");
        running = false;
        if (in != null) try { in.close(); } catch (Exception e) {}
        if (out != null) try { out.close(); } catch (Exception e) {}
        server.clientList.remove(this);
    }

    void sendMessage(String msg) {
        out.println(msg);
        out.flush();
    }

    public void run() {
        try {
            System.out.println("ClientHandler.run()");
            out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out.println("Welcome!");
            out.flush();
        } catch (Exception e) {
            System.out.println("error occurred.");
            e.printStackTrace();
        }
        while (running && !Thread.currentThread().isInterrupted()) {
            try {
                String line = in.readLine();
                System.out.println("message received - " + line);
                if ("exit".equals(line)) {
                    break;
                }
                if ("down".equals(line)) {
                    server.shutdown(); // exception
                    break;
                }
                server.broadcast(line);
            } catch (Exception e) {
                System.out.println("error occurred. connection will be closed.");
                e.printStackTrace();
                break;
            }
        }
        disconnect();
    }

}

class ConsoleClient extends Thread {

    boolean running = true;
    Socket socket;
    BufferedReader in;
    PrintWriter out;
    ConsoleReader console;

    public ConsoleClient() throws Exception {
        this.socket = new Socket("localhost", 8088);
        this.console = new ConsoleReader(this);
        this.console.start();
    }

    void sendMessage(String message) {
        System.out.println("ConsoleClient.sendMessage: " + message);
        out.println(message);
        out.flush();
    }

    void disconnect() {
        System.out.println("ConsoleClient.disconnect()");
        running = false;
        if (in != null) try { in.close(); } catch (Exception e) {}
        if (out != null) try { out.close(); } catch (Exception e) {}
        console.shutdown();
    }

    public void run() {
        System.out.println("ConsoleClient.run()");
        try {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));
        } catch (Exception e) {
            System.out.println("error occurred.");
            e.printStackTrace();
            running = false;
        }
        System.out.println("stream created.");
        while (running && !Thread.currentThread().isInterrupted()) {
            try {
                String line = in.readLine();
                if (line == null) {
                    disconnect();
                    break;
                }
                System.out.println(line);
            } catch (Exception e) {
                System.out.println("error occurred. system will be down.");
                e.printStackTrace();
                running = false;
                break;
            }
        }
    }

}

class ConsoleReader extends Thread {
    ConsoleClient cc;
    boolean running = true;
    ConsoleReader(ConsoleClient cc) {
        this.cc = cc;
    }
    void shutdown() {
        running = false;
        this.interrupt();
    }
    public void run() {
        System.out.println("ConsoleReader.run()");
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        try {
            while (running
                    && !Thread.currentThread().isInterrupted()) {
                System.out.print("input: ");
                String line = in.readLine();
                if (line == null) {
                    running = false;
                    cc.disconnect();
                    break;
                }
                System.out.println("> " + line);
                cc.sendMessage(line);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class SocketTest {
    public static void main(String[] args) throws Exception {
        if ("server".equals(args[0])) {
            new Server().start();
        }
        else if ("client".equals(args[0])) {
            new ConsoleClient().start();
        }
    }
}

```



**`Server Class` 클래스:**

- `Server` 클래스는 서버 역할을 하는 클래스로, 클라이언트의 연결을 기다리고 연결된 클라이언트들에 대한 처리를 담당한다.

- 서버는 `ServerSocket`을 사용하여 run()에 특정 포트(여기서는 8088)에서 클라이언트의 연결을 수락한다.

  ==> 무한 루프인 이유는 여러 클라이언트의 연결을 관리하기 위함임.

- `Server` 클래스는 `ClientHandler` 스레드를 생성하여 클라이언트와의 통신을 처리한다.



**`ClientHandler` 클래스:**

- `ClientHandler` 클래스는 각 클라이언트의 통신을 처리하는 스레드이다.
- 각 클라이언트와의 입출력 스트림을 생성하고, 클라이언트로부터 메시지를 수신하여 서버에 브로드캐스팅한다.
- 클라이언트가 "exit"을 보내면 해당 클라이언트의 스레드를 종료하고 연결을 닫는다.
- "down"을 받으면 서버를 종료시키고 클라이언트 연결도 종료한다.



**`ConsoleClient` 및 `ConsoleReader` 클래스:**

- `ConsoleClient` 클래스는 클라이언트 역할을 하는 클래스로, 서버에 연결하여 콘솔에서 메시지를 입력하고 서버로 전송한다.
- `ConsoleReader` 클래스는 콘솔에서 입력을 읽어와서 서버로 전송하는 역할을 하는 스레드이다.



**`SocketTest` 클래스 (메인 클래스):**

- `SocketTest` 클래스는 프로그램의 진입점으로, 명령행 매개변수에 따라 서버 또는 클라이언트 역할을 수행한다.
- "server"를 인자로 주면 서버로 동작하고, "client"를 인자로 주면 클라이언트로 동작한다. 





## ✏️`SocketTest` 클래스의 프로세스에 대한 순서

1. **프로그램 실행:**

   - 프로그램을 실행할 때 명령행 인자로 "server" 또는 "client"를 전달한다.
   - "server"를 인자로 주면 서버로 동작하며, "client"를 인자로 주면 클라이언트로 동작한다.

2. **서버 동작:**

   - "server"를 명령행 인자로 받았을 경우, `Server` 클래스의 인스턴스를 생성하고 스레드로 시작한다.
   - `Server` 클래스는 `ServerSocket`을 사용하여 클라이언트의 연결을 기다리고, 연결되면 `ClientHandler` 스레드를 생성하여 해당 클라이언트와의 통신을 담당한다.
   - 서버는 브로드캐스팅을 통해 연결된 모든 클라이언트에게 메시지를 전송한다.
   - "down" 메시지를 받으면 서버를 종료하고 클라이언트 연결도 종료한다.

3. **클라이언트 동작:**

   - "client"를 명령행 인자로 받았을 경우, `ConsoleClient` 클래스의 인스턴스를 생성하고 스레드로 시작한다.
   - `ConsoleClient` 클래스는 서버에 소켓 연결을 시도하고, 연결이 성공하면 `ConsoleReader` 스레드를 생성하여 사용자의 콘솔 입력을 읽어와 서버로 전송한다.
   - 서버에서 받은 메시지를 화면에 출력한다.
   - "exit" 메시지를 입력하면 클라이언트 프로그램을 종료한다.

4. **통신 프로세스:**

   - 클라이언트에서 서버로 메시지를 전송할 때는 `ConsoleClient`의 `sendMessage` 메서드를 사용한다.
   - 서버는 받은 메시지를 모든 클라이언트에게 브로드캐스팅한다.
   - 서버에서 "exit" 메시지를 받으면 해당 클라이언트와의 연결을 종료하고, "down" 메시지를 받으면 서버와 모든 클라이언트의 연결을 종료한다.

   